# -*- coding: utf-8 -*-
"""258_Hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZIykFd3DfrhxDrdg0qMKT6y3hHz-Fh0Z
"""

import gzip
from collections import defaultdict
import math
import scipy.optimize
import numpy
import string
from sklearn import linear_model
from tqdm.notebook import tqdm
import scipy.optimize as opt
import random

def assertFloat(x):
    assert type(float(x)) == float

def assertFloatList(items, N):
    assert len(items) == N
    assert [type(float(x)) for x in items] == [float]*N

def readGz(path):
    for l in gzip.open(path, 'rt'):
        yield eval(l)

def readCSV(path):
    f = gzip.open(path, 'rt')
    f.readline()
    for l in f:
        u,b,r = l.strip().split(',')
        r = int(r)
        yield u,b,r

answers = {}

allRatings = []
for l in readCSV("train_Interactions.csv.gz"):
    allRatings.append(l)
# t = []
# for i in allRatings:
#   if i[2] == 5:
#     t.append(i)
# print(len(t))

ratingsTrain = allRatings[:190000]
ratingsValid = allRatings[190000:]
ratingsPerUser = defaultdict(list)
ratingsPerItem = defaultdict(list)
for u,b,r in ratingsTrain:
    ratingsPerUser[u].append((b,r))
    ratingsPerItem[b].append((u,r))

(allRatings[:10])

type(ratingsValid[:10])

from tqdm.notebook import tqdm
import time

# for i in tqdm(ratingsValid):
#   time.sleep(.001)
#   pass

usersPerItem = defaultdict(set) # Maps an item to the users who rated it
itemsPerUser = defaultdict(set) # Maps a user to the items that they rated

ratingDict = {} # To retrieve a rating for a specific user/item pair

for i in ratingsTrain:
  # if i[0] not in itemsPerUser:
  #   itemsPerUser[i[0]] = [i[1]]
  # else:
  itemsPerUser[i[0]].add(((i[1],1)))
  
  # if i[1] not in usersPerItem:
  #   usersPerItem[i[1]] = [i[0]]
  # else:
  usersPerItem[i[1]].add((i[0],1))

  ratingDict[(i[0],i[1])] = i[2]

  # print(itemsPerUser)

# print(itemsPerUser)
print(max(len(itemsPerUser[x]) for x in itemsPerUser))

n= len(ratingsValid)
allBooks = set(usersPerItem.keys())
for i in tqdm(range(n)):
  # creating non read set
  notRead = allBooks - set(itemsPerUser[ratingsValid[i][0]])
  randi = random.sample(notRead,1)
  
  # adding negative Samples
  ratingsValid.append((ratingsValid[i][0], randi[0], -1))

cntBooksPop = defaultdict(int)
for i in tqdm(itemsPerUser):
  # print(itemsPerUser[i])
  for j in itemsPerUser[i]:
    cntBooksPop[j[0]]+=1
  
cntBooksPop = dict(sorted(cntBooksPop.items(), key=lambda item: item[1],reverse=True))
print(cntBooksPop)

# cntBooksPop["b69684851"] +=1

totalReadings = sum(cntBooksPop.values())
print(totalReadings)
print(len(cntBooksPop.values()))

cnt = 0
top1Per = set()
for i in cntBooksPop:
  top1Per.add(i)
  cnt+=cntBooksPop[i]
  if cnt>totalReadings//2:
    break
len(top1Per)

# Evaluating
# it is mentioned that the baseline models returns whether a book has been read or not based on most pop
# print(ratingsValid[10000])
corr_pred = 0
for i in tqdm(ratingsValid):
  if i[1] in top1Per:
    if i[2]>=0:
      corr_pred+=1
  else:
    if i[2]==-1:
      corr_pred+=1
acc = corr_pred/len(ratingsValid)
print("Accuracy = ",corr_pred/len(ratingsValid)*100,"%")
answers["Q1"] = acc
print(answers)

"""# Q2)

"""

accuracy = []
for k in tqdm(range(1,101)):
  # print(type(i))
  # print(totalReadings)
  cnt = 0
  top1Per = set()
  for i in cntBooksPop:
    top1Per.add(i)
    cnt+=cntBooksPop[i]
    if cnt > (k*totalReadings)//100:
      break
  corr_pred = 0
  for i in (ratingsValid):
    if i[1] in top1Per:
      if i[2]>=0:
        corr_pred+=1
    else:
      if i[2]==-1:
        corr_pred+=1
  acc = corr_pred/len(ratingsValid)
  accuracy.append(acc)

max(accuracy)

print((accuracy.index(max(accuracy))+1),"\b% of the popular books")

answers["Q2"] = ((accuracy.index(max(accuracy))+1)/100,max(accuracy))

answers

"""# Q3"""

def Jaccard(s1, s2):
    try:
      return len(s1.intersection(s2))/len(s1.union(s2))
    except:
      return 0

accuracy = []
for thres in tqdm(range(1,101)):
  corr_pred = 0
  for i in (ratingsValid):
    # print(i)
    # break
    user = i[0]
    bpred = i[1]
    # print(user,bpred)
    # break
    jaccardd = []
    s1 = usersPerItem[bpred]
    s1.discard(user)
    for j in itemsPerUser[user]:
      
      s2 = usersPerItem[j[0]]
      # print(s1)
      # print(j[0])
      
      s2.discard(user)
      
      # break
      
      jaccardd.append(Jaccard(s1,s2))
    # break
    read = 0
    if jaccardd!=[] and max(jaccardd)>thres/100:
      read=1
    
    if read == 1 and i[2]>=0:
      corr_pred+=1
    elif read == 0 and i[2]==-1:
      corr_pred+=1

  acc = corr_pred/len(ratingsValid)
  accuracy.append(acc)

print(max(accuracy))
print((accuracy.index(max(accuracy))+1),"%")

answers["Q3"] = max(accuracy)

answers

"""# Q4"""

combiAcc = []

"""## using old optimization values"""

# accuracy = []
corr_pred = 0
for i in tqdm(ratingsValid):
  # print(i)
  # break
  user = i[0]
  bpred = i[1]
  # print(user,bpred)
  # break
  jaccardd = []
  s1 = usersPerItem[bpred]
  s1.discard(user)
  for j in itemsPerUser[user]:
    
    s2 = usersPerItem[j[0]]
    # print(s1)
    # print(j[0])
    
    s2.discard(user)
    
    # break
    
    jaccardd.append(Jaccard(s1,s2))

    cnt = 0
    top1Per = set()
    for k in cntBooksPop:
      top1Per.add(k)
      cnt+=cntBooksPop[k]
      if cnt > (74*totalReadings)//100:
        break
  # break
  read = 0
  if jaccardd!=[] and max(jaccardd)>1/100 and bpred in top1Per:
    read=1
  
  if read == 1 and i[2]>=0:
    corr_pred+=1
  elif read == 0 and i[2]==-1:
    corr_pred+=1

acc = corr_pred/len(ratingsValid)
# accuracy.append(acc)

print(acc)
combiAcc.append(acc)
# print((accuracy.index(max(accuracy))+1),"%")

"""## optimizing jaccard only"""

accuracy = []
for thres in tqdm(range(1,101)):
  corr_pred = 0
  cnt = 0
  top1Per = set()
  for k in cntBooksPop:
    top1Per.add(k)
    cnt+=cntBooksPop[k]
    if cnt > (74*totalReadings)//100:
      break
  for i in (ratingsValid):
    # print(i)
    # break
    user = i[0]
    bpred = i[1]
    # print(user,bpred)
    # break
    jaccardd = []
    for j in itemsPerUser[user]:
      s1 = usersPerItem[bpred]
      s2 = usersPerItem[j[0]]
      # print(s1)
      # print(j[0])
      s1.discard(user)
      s2.discard(user)
      
      # break
      
      jaccardd.append(Jaccard(s1,s2))
    # break

    

    read = 0
    if jaccardd!=[] and max(jaccardd)>thres/100 and bpred in top1Per:
      read=1
    
    if read == 1 and i[2]>0:
      corr_pred+=1
    elif read == 0 and i[2]==0:
      corr_pred+=1

  acc = corr_pred/len(ratingsValid)
  accuracy.append(acc)

print(max(accuracy))
print((accuracy.index(max(accuracy))+1),"%")
combiAcc.append(max(accuracy))

"""## optimizing baseline only"""

accuracy = []
for thres in tqdm(range(1,101)):
  corr_pred = 0
  cnt = 0
  top1Per = set()
  for k in cntBooksPop:
    top1Per.add(k)
    cnt+=cntBooksPop[k]
    if cnt > (thres*totalReadings)//100:
      break
  for i in (ratingsValid):
    # print(i)
    # break
    user = i[0]
    bpred = i[1]
    # print(user,bpred)
    # break
    jaccardd = []
    for j in itemsPerUser[user]:
      s1 = usersPerItem[bpred]
      s2 = usersPerItem[j[0]]
      # print(s1)
      # print(j[0])
      s1.discard(user)
      s2.discard(user)
      
      # break
      
      jaccardd.append(Jaccard(s1,s2))
    # break

    

    read = 0
    if jaccardd!=[] and max(jaccardd)>(1/100) and (bpred in top1Per):
      read=1
    
    if read == 1 and i[2]>0:
      corr_pred+=1
    elif read == 0 and i[2]==0:
      corr_pred+=1

  acc = corr_pred/len(ratingsValid)
  accuracy.append(acc)

print(max(accuracy))
print((accuracy.index(max(accuracy))+1),"%")


print(totalReadings)
combiAcc.append(max(accuracy))

# accuracy = []
corr_pred = 0
cnt = 0
top1Per = set()
for k in cntBooksPop:
  top1Per.add(k)
  cnt+=cntBooksPop[k]
  if cnt > (77*totalReadings)//100:
    break
for i in tqdm(ratingsValid):
  # print(i)
  # break
  user = i[0]
  bpred = i[1]
  # print(user,bpred)
  # break
  jaccardd = []
  for j in itemsPerUser[user]:
    s1 = usersPerItem[bpred]
    s2 = usersPerItem[j[0]]
    # print(s1)
    # print(j[0])
    s1.discard(user)
    s2.discard(user)
    
    # break
    
    jaccardd.append(Jaccard(s1,s2))

    
  # break
  read = 0
  if jaccardd!=[] and max(jaccardd)>1/100 and bpred in top1Per:
    read=1
  
  if read == 1 and i[2]>0:
    corr_pred+=1
  elif read == 0 and i[2]==0:
    corr_pred+=1

acc = corr_pred/len(ratingsValid)
# accuracy.append(acc)

print(acc)
# print((accuracy.index(max(accuracy))+1),"%")
combiAcc.append(acc)

answers["Q4"]=max(combiAcc)
print(answers)

"""# Q5)"""

import csv
# accuracy = []
testData = []
with open('/content/pairs_Read.csv', newline='') as csvfile:
  f = csv.reader(csvfile, delimiter=' ', quotechar='|')
  next(f)
  for i in f:
    testData.append(i[0].split(','))
    # break

print(testData[0])
# corr_pred = 0
cnt = 0
top1Per = set()
for k in cntBooksPop:
  top1Per.add(k)
  cnt+=cntBooksPop[k]
  if cnt > (74*totalReadings)//100:
    break
with open("Q5_pred.txt",'w',encoding = 'utf-8') as f:
  for i in tqdm(testData):
    # print(i)
    # break
    user = i[0]
    bpred = i[1]
    # print(user,bpred)
    # break
    jaccardd = []
    for j in itemsPerUser[user]:
      s1 = usersPerItem[bpred]
      s2 = usersPerItem[j[0]]
      # print(s1)
      # print(j[0])
      s1.discard(user)
      s2.discard(user)
      
      # break
      
      jaccardd.append(Jaccard(s1,s2))

      
    # break
    read = 0
    if jaccardd!=[] and max(jaccardd)>1/100 and bpred in top1Per:
      read=1
    f.write(str((user,bpred,read))+"\n")
  #   if read == 1 and i[2]>0:
  #     corr_pred+=1
  #   elif read == 0 and i[2]==0:
  #     corr_pred+=1

  # acc = corr_pred/len(ratingsValid)
  # # accuracy.append(acc)

  # print(acc)
  # print((accuracy.index(max(accuracy))+1),"%")

answers["Q5"]="I confirm that I have uploaded an assignment submission to gradescope"

answers

"""# Q9)"""



allRatings = []
for l in readCSV("train_Interactions.csv.gz"):
    allRatings.append(l)

ratingsTrain = allRatings[:190000]
ratingsValid = allRatings[190000:]
ratingsPerUser = defaultdict(list)
ratingsPerItem = defaultdict(list)
for u,b,r in ratingsTrain:
    ratingsPerUser[u].append((b,r))
    ratingsPerItem[b].append((u,r))

(allRatings[:10])

type(ratingsValid[:10])

from tqdm.notebook import tqdm
import time

# for i in tqdm(ratingsValid):
#   time.sleep(.001)
#   pass

usersPerItem = defaultdict(set) # Maps an item to the users who rated it
itemsPerUser = defaultdict(set) # Maps a user to the items that they rated

ratingDict = {} # To retrieve a rating for a specific user/item pair

for i in ratingsTrain:
  # if i[0] not in itemsPerUser:
  #   itemsPerUser[i[0]] = [i[1]]
  # else:
  itemsPerUser[i[0]].add(((i[1],1)))
  
  # if i[1] not in usersPerItem:
  #   usersPerItem[i[1]] = [i[0]]
  # else:
  usersPerItem[i[1]].add((i[0],1))

  ratingDict[(i[0],i[1])] = i[2]

  # print(itemsPerUser)

globalAvg = sum(ratingDict.values())/len(ratingDict)

# import scipy.optimize
ratingsTrain[0]
# Bu Bi Rui

alpha = globalAvg

Bu = defaultdict(float)
for user in tqdm(itemsPerUser):
  # print("Ratings",len(ratingsPerUser[user]))
  # print(ratingsPerUser[user])
  ratiTmp = 0
  for i in ratingsPerUser[user]:
    ratiTmp+=i[1]
  Bu[user] = (ratiTmp/len(ratingsPerUser[user]))

print(Bu)

Bi = defaultdict(float)
for item in tqdm(usersPerItem):
  # print("Ratings",len(ratingsPerUser[user]))
  # print(ratingsPerUser[user])
  ratiTmp = 0
  # print(ratingsPerItem[item])
  # break
  for i in ratingsPerItem[item]:
    ratiTmp+=i[1]
  Bi[item] = (ratiTmp/len(ratingsPerItem[item]))

print(Bi)

alpha = globalAvg
lamb = 1
while True:
  # alpha
  palpha = alpha
  # print(Bu['u67805239'])
  numi = 0
  for i in ratingsTrain:
    user = i[0]
    item = i[1]
    rating = i[2]
    numi += rating-(Bu[user]+Bi[item])
  alpha = numi/len(ratingsTrain)

  # bu:
  
  for user in itemsPerUser: # gives me user names
    numi = 0
    for item in itemsPerUser[user]: # items of that uer
      item = item[0] # one item
      numi+=ratingDict[(user,item)]-alpha-Bi[item]
    deno = lamb+len(itemsPerUser[user])
    Bu[user] = numi/deno
  
  # bi:
  
  for item in usersPerItem:
    numi = 0
    for user in usersPerItem[item]:
      user = user[0]
      numi+=ratingDict[(user,item)]-alpha-Bu[user]
    deno = lamb+len(usersPerItem[item])
    Bi[item] = numi/deno
  # print(palpha,alpha)
  if round(palpha,5) == round(alpha,5):
    break
# print("final",palpha,alpha)

# print(round(alpha,9))

# accuracy = []
sumi = 0
for i in tqdm(ratingsValid):
  # print(i)
  # break
  user = i[0]
  bpred = i[1]
  rating = i[2]
  # print(user,bpred)
  # break
  # print(i)
  rating_pred = alpha+Bu[user]+Bi[bpred]

  sumi+=(rating_pred-rating)**2
  

MSE = sumi/len(ratingsValid)
# accuracy.append(acc)
print(MSE)
# print(acc)
# print((accuracy.index(max(accuracy))+1),"%")
answers["Q9"] = MSE

answers

"""# Q10)"""

maxiU = max(Bu, key=Bu.get)
print(maxiU,Bu[maxiU])

miniU = min(Bu, key=Bu.get)
print(miniU,Bu[miniU])

answers["Q10"] = [maxiU,miniU, Bu[maxiU], Bu[miniU]]

answers



"""# Q11)"""

allRatings = []
for l in readCSV("train_Interactions.csv.gz"):
    allRatings.append(l)

ratingsTrain = allRatings[:190000]
ratingsValid = allRatings[190000:]
ratingsPerUser = defaultdict(list)
ratingsPerItem = defaultdict(list)
for u,b,r in ratingsTrain:
    ratingsPerUser[u].append((b,r))
    ratingsPerItem[b].append((u,r))

(allRatings[:10])

type(ratingsValid[:10])

from tqdm.notebook import tqdm
import time

# for i in tqdm(ratingsValid):
#   time.sleep(.001)
#   pass

usersPerItem = defaultdict(set) # Maps an item to the users who rated it
itemsPerUser = defaultdict(set) # Maps a user to the items that they rated

ratingDict = {} # To retrieve a rating for a specific user/item pair

for i in ratingsTrain:
  # if i[0] not in itemsPerUser:
  #   itemsPerUser[i[0]] = [i[1]]
  # else:
  itemsPerUser[i[0]].add(((i[1],1)))
  
  # if i[1] not in usersPerItem:
  #   usersPerItem[i[1]] = [i[0]]
  # else:
  usersPerItem[i[1]].add((i[0],1))

  ratingDict[(i[0],i[1])] = i[2]

  # print(itemsPerUser)

globalAvg = sum(ratingDict.values())/len(ratingDict)

def modell(lamb):
  # lamb=1
  Bu = defaultdict(float)
  for user in itemsPerUser:
    # print("Ratings",len(ratingsPerUser[user]))
    # print(ratingsPerUser[user])
    ratiTmp = 0
    for i in ratingsPerUser[user]:
      ratiTmp+=i[1]
    Bu[user] = (ratiTmp/len(ratingsPerUser[user]))

  # print(Bu)


  # BI
  Bi = defaultdict(float)
  for item in usersPerItem:
    # print("Ratings",len(ratingsPerUser[user]))
    # print(ratingsPerUser[user])
    ratiTmp = 0
    # print(ratingsPerItem[item])
    # break
    for i in ratingsPerItem[item]:
      ratiTmp+=i[1]
    Bi[item] = (ratiTmp/len(ratingsPerItem[item]))

  # print(Bi)

  alpha = globalAvg
  # lamb = 1
  while True:
    # alpha
    palpha = alpha
    # print(Bu['u67805239'])
    numi = 0
    for i in ratingsTrain:
      user = i[0]
      item = i[1]
      rating = i[2]
      # print(rating,Bu[user],Bi[item])
      numi += rating-Bu[user]-Bi[item]
      # print(numi)
    # print("NUMI",numi)
    alpha = numi/len(ratingsTrain)
    # print("ALPHA",alpha)
    f=1
    # bu:
    
    for user in itemsPerUser: # gives me user names
      numi = 0
      for item in itemsPerUser[user]: # items of that uer
        item = item[0] # one item
        numi+=ratingDict[(user,item)]-alpha-Bi[item]
      deno = float(lamb)+len(itemsPerUser[user])
      # print(deno)
      Bu[user] = numi/deno
    
    # bi:
    
    for item in usersPerItem:
      numi = 0
      for user in usersPerItem[item]:
        user = user[0]
        numi+=ratingDict[(user,item)]-alpha-Bu[user]
      deno = float(lamb)+len(usersPerItem[item])
      Bi[item] = numi/deno
    # print(palpha,alpha)
    if round(palpha,2) == round(alpha,2):
      break
  # print("final",palpha,alpha)
  # accuracy = []

  # MSE
  sumi = 0
  for i in tqdm(ratingsValid):
    # print(i)
    # break
    user = i[0]
    bpred = i[1]
    rating = i[2]
    # print(user,bpred)
    # break
    # print(i)
    rating_pred = alpha+Bu[user]+Bi[bpred]

    sumi+=(rating_pred-rating)**2
    

  MSE = sumi/len(ratingsValid)
  print("MSE",MSE,float(lamb))
  return MSE
  # accuracy.append(acc)

  # print(acc)
  # print((accuracy.index(max(accuracy))+1),"%")

# lamb = 1
# # print(round(1.245532,2))
# result = opt.minimize(modell,lamb)

# print(result)

lamb = 10**-5
# print(round(1.245532,2))
result = opt.minimize(modell,lamb)

print(result)

type(result)

answers["Q11"] = [result["x"][0],result["fun"]]

answers

modell(1)

